<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>运动修改器之利用三星健康稳定修改支付宝</title>
    <link href="/2017/09/04/O%CC%82E%CC%88%C2%B6%C2%AF%C3%90%C3%9E%C2%B8A%CC%88%C3%86%C3%B7O%CC%88%C2%AEA%CC%80u%CC%82O%CC%81A%CC%83E%CC%80y%CC%81%C3%90C%CC%A7%C2%BD%C2%A1%C2%BF%C2%B5I%CC%82E%CC%80%C2%B6%C2%A8%C3%90%C3%9E%C2%B8A%CC%88O%CC%88%C2%A7%C2%B8%C2%B6%C2%B1%C2%A6/"/>
    <url>/2017/09/04/O%CC%82E%CC%88%C2%B6%C2%AF%C3%90%C3%9E%C2%B8A%CC%88%C3%86%C3%B7O%CC%88%C2%AEA%CC%80u%CC%82O%CC%81A%CC%83E%CC%80y%CC%81%C3%90C%CC%A7%C2%BD%C2%A1%C2%BF%C2%B5I%CC%82E%CC%80%C2%B6%C2%A8%C3%90%C3%9E%C2%B8A%CC%88O%CC%88%C2%A7%C2%B8%C2%B6%C2%B1%C2%A6/</url>
    
    <content type="html"><![CDATA[<p>支付宝的步数修改越来越难，这次我们来利用三星健康曲线修改支付宝，目前测试很稳定。</p><a id="more"></a><h3 id="9月13更新"><a href="#9月13更新" class="headerlink" title="9月13更新"></a>9月13更新</h3><pre><code>如果伪装失败可以使用应用变量伪装试试。</code></pre><h3 id="需要的前提条件"><a href="#需要的前提条件" class="headerlink" title="需要的前提条件"></a>需要的前提条件</h3><ul><li>Android手机</li><li>手机必须Root</li><li>手机必须Xposed框架</li></ul><h3 id="修改步骤"><a href="#修改步骤" class="headerlink" title="修改步骤"></a>修改步骤</h3><ol><li>去应用市场下载三星健康，并安装运行：</li></ol><p><img src="http://ww1.sinaimg.cn/mw690/006VAonPgy1fj7ijfn5oqj31401z4dkl.jpg"></p><ol start="2"><li><p>手机安装最新版的运动修改器（2.0.9以上），并在xposed里面勾选，然后重启</p><p> 下载地址：<a href="http://caiyao.name/releases">http://caiyao.name/releases</a></p></li><li><p>打开运动修改器，点击支付宝，然后点击一键伪装成三星S8（伪装成三星手机，支付宝才回同步三星健康的数据），需要root权限，注意，这一步会清空支付宝的数据：</p></li></ol><p><img src="http://ww1.sinaimg.cn/mw690/006VAonPgy1fj7ioq4j8bj31401z4jx4.jpg"></p><p><img src="http://ww1.sinaimg.cn/mw690/006VAonPgy1fj7ird7hytj31401z4ah1.jpg"></p><ol start="4"><li><p>打开支付宝，登录，进入运动界面，点击右上角设置：<br><img src="http://ww1.sinaimg.cn/mw690/006VAonPgy1fj7iqhqo0pj31401z4arc.jpg"></p></li><li><p>然后点击运动数据记录，打开三星健康，并允许读取三星健康数据：<br><img src="http://ww1.sinaimg.cn/mw690/006VAonPgy1fj7isze23ij31401z4gp9.jpg"></p></li></ol><p><img src="http://ww1.sinaimg.cn/mw690/006VAonPgy1fj7itnhs4kj31401z4n27.jpg"></p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>完成以上安装步骤后，返回重新进入支付宝运动界面，就会发现三星健康的步数已经同步过来啦<br><img src="http://ww1.sinaimg.cn/mw690/006VAonPgy1fj7jz7pntzj31401z4n0a.jpg"></p><p><img src="http://ww1.sinaimg.cn/mw690/006VAonPgy1fj7jzt7gr4j31401z4kgq.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>玩机教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运动修改</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QQ AR红包进阶玩法(二)</title>
    <link href="/2017/01/22/QQ%20AR%C2%BAi%CC%80%C2%B0u%CC%88%C2%BD%C3%B8%C2%BD%C3%97I%CC%81%C3%A6%C2%B7%C2%A8(%C2%B6%C3%BE)/"/>
    <url>/2017/01/22/QQ%20AR%C2%BAi%CC%80%C2%B0u%CC%88%C2%BD%C3%B8%C2%BD%C3%97I%CC%81%C3%A6%C2%B7%C2%A8(%C2%B6%C3%BE)/</url>
    
    <content type="html"><![CDATA[<p>上一次讲了怎么通过修改位置，坐在家里领取大红包，这次来讲一个更高级的玩法，QQ内置位置摇杆移动。不得不说微信公众号的排版真是大坑，预览的时候都是正常的，发出去就不正常了，还不能改。</p><a id="more"></a><h3 id="需要的前提条件"><a href="#需要的前提条件" class="headerlink" title="需要的前提条件"></a>需要的前提条件</h3><ul><li>Android手机</li><li>手机必须Root</li><li>手机必须Xposed框架，这次是必须哦</li></ul><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li>下载QQ6.6.5调试版本，并安装，登录在设置里打开如图中以下选项：</li></ol><p>下载地址：<a href="https://pan.baidu.com/s/1eRBC5xg">https://pan.baidu.com/s/1eRBC5xg</a><br><img src="http://wx1.sinaimg.cn/mw690/723b2af4gy1fbzuv7paw1j21401z4q87.jpg"></p><ol start="2"><li><p>手机安装核心破解xposed模块或者使用幸运破解器里面的核心破解功能，以便能够进行降级安装<br><img src="http://wx3.sinaimg.cn/mw690/723b2af4gy1fbzv2j1r5lj20u01hcq5t.jpg"></p></li><li><p>覆盖安装6.6.8或6.6.9版本QQ，记得是覆盖安装，有些手机ROM手动降级安装会清除数据，这时一定要用root方式强制安装，否则被清除数据就失效了。</p></li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>完成以上安装步骤后，进入QQ AR红包界面就会出现设置摇杆,滑动摇杆就可以自由自在的飞舞啦，想去哪里就去哪里<br><img src="http://wx3.sinaimg.cn/mw690/723b2af4gy1fbzuv6hhdrj20f00qojsy.jpg"><br><img src="http://wx1.sinaimg.cn/mw690/723b2af4gy1fbzuv75713j20f00qojt2.jpg"><br><img src="http://wx2.sinaimg.cn/mw690/723b2af4gy1fc0ackq8fkj20u01hcth1.jpg"></p><p><a href="http://shang.qq.com/wpa/qunwpa?idkey=cb1680a5052a631a7ce40ca3063530d016c9fb2664eb4a74465b0398b9e696d9">如果你有更多问题可以QQ群290873461讨论</a></p>]]></content>
    
    
    <categories>
      
      <category>玩机教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QQ 红包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QQ AR红包进阶玩法(一)</title>
    <link href="/2017/01/22/QQ%20AR%C2%BAi%CC%80%C2%B0u%CC%88%C2%BD%C3%B8%C2%BD%C3%97I%CC%81%C3%A6%C2%B7%C2%A8(O%CC%80%C2%BB)/"/>
    <url>/2017/01/22/QQ%20AR%C2%BAi%CC%80%C2%B0u%CC%88%C2%BD%C3%B8%C2%BD%C3%97I%CC%81%C3%A6%C2%B7%C2%A8(O%CC%80%C2%BB)/</url>
    
    <content type="html"><![CDATA[<p>最近支付宝QQ红包大战又开始了，前两天支付宝集福占据风头，这两天又换QQ抢风头了，相比支付宝集福还不知道能分几毛，QQ可是实打实的现金红包，每天每个QQ可领取一次8-188的现金红包，比支付宝爽快多了，不过，毕竟是AR红包，要去指定的地点领取，那么作为技术宅，怎么能任人摆布╭(╯^╰)╮。</p><a id="more"></a><h3 id="需要的前提条件"><a href="#需要的前提条件" class="headerlink" title="需要的前提条件"></a>需要的前提条件</h3><ul><li>Android手机</li><li>手机必须Root</li><li>手机最好安装Xposed框架，没有也能玩，不过会有限制</li></ul><p><strong>以上条件不符合请关闭本页，先去满足以上条件</strong></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>大红包的位置</li></ol><p><img src="http://wx2.sinaimg.cn/mw690/723b2af4gy1fbzr1mpzlgj209o0p741d.jpg"></p><ol start="2"><li>安装一个伪装手机位置的软件，这里我们使用天下任我行</li></ol><p><a href="http://caiyao.name/releases/fake.apk">点击下载</a></p><p>这个软件是收费的，不过非常好用，可以免费试用5小时，如果你有xposed就有下面两种方式破解：</p><ul><li>禁用软件SD卡权限，使用应用产量等修改手机信息，清除软件数据即可再次试用5小时。</li><li>下载对话框取消Xposed模块，出现试用到期对话框，点击返回即可继续使用。</li></ul><p>以上方法任选一个。</p><p>如果你没有xposed，可以选择禁用SD卡权限后，手动修改手机型号，清除任我行数据，获得再次试用。</p><h3 id="去抢大红包"><a href="#去抢大红包" class="headerlink" title="去抢大红包"></a>去抢大红包</h3><ol><li>在任我行软件里面搜索上面任意一个有大红包的地方，选定位置开始模拟，在任我行设置里面的隐藏自己选项中对QQ隐藏。</li><li>结束QQ进程，重新打开QQ就会发现已经飞到了大红包的位置，等到12点，大红包出现即可领取，记住是金色的红包哟。</li></ol><p><a href="http://shang.qq.com/wpa/qunwpa?idkey=cb1680a5052a631a7ce40ca3063530d016c9fb2664eb4a74465b0398b9e696d9">如果你有更多问题可以QQ群290873461讨论</a></p>]]></content>
    
    
    <categories>
      
      <category>玩机教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QQ 红包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐讯k2刷不死Uboot和华硕固件教程</title>
    <link href="/2016/12/16/i%CC%80%C2%B3N%CC%83%C2%B6k2E%CC%88%C2%A2%C2%B2%C2%BBE%CC%88A%CC%80Uboot%C2%BAI%CC%81%C2%BB%C2%AAE%CC%88%C2%B6%C2%B9I%CC%80%C2%BC%C3%BE%C2%BDI%CC%80%C2%B3I%CC%80/"/>
    <url>/2016/12/16/i%CC%80%C2%B3N%CC%83%C2%B6k2E%CC%88%C2%A2%C2%B2%C2%BBE%CC%88A%CC%80Uboot%C2%BAI%CC%81%C2%BB%C2%AAE%CC%88%C2%B6%C2%B9I%CC%80%C2%BC%C3%BE%C2%BDI%CC%80%C2%B3I%CC%80/</url>
    
    <content type="html"><![CDATA[<p>斐讯k2凭借免费的旗号一直占据着路由器销量榜首，而且可以刷华硕固件，自带openvpn和ss等代理（特殊用途你懂得），在下也禁不住诱惑买了个玩玩，在此分享一下刷机教程给大家玩玩。</p><a id="more"></a><h3 id="购买途径"><a href="#购买途径" class="headerlink" title="购买途径"></a>购买途径</h3><p>大家都知道斐讯k2需要先支付399，路由器买回来激活k码得399元理财产品，一个月后可提现，很多人都心慌慌，怕斐讯卷钱跑了不敢买，这里推荐一个靠谱途径，那就是京东，京东自营也有斐讯k2，而且可以用白条支付，30天免息，刚好和斐讯的理财产品取现时间相同，咱们在京东上买就相当于多了一道保险，在下也是走的这个渠道，昨天刚下车。</p><p><a href="http://union.click.jd.com/jdc?e=&p=AyIHZR5bEgAWBVMfWyUBFQdRElsUMlZYDUUEJVtXQhQQRQtaV1MJBABAHUBZCQVYEgIWDlUaRExHTlplTBNzRnFwL1g4Z3wWThBpC2ZaSwcja1cZMhM3VRpaFAIRB1QaUiUyc3VlTTUVAxMGVBpaHAAUN1ESWRwAGwZcHGsVBxsHXB5TFgUSBF0caxcCIgdRE10cARIOVwdTEwUWA1wraw==&t=W1dCFBBFC1pXUwkEAEAdQFkJBVgSAhYOVRpETEdOWg==">直达京东链接</a></p><h3 id="支持的版本"><a href="#支持的版本" class="headerlink" title="支持的版本"></a>支持的版本</h3><p>V22.3.15.128<br>V22.3.15.232<br>V22.3.17.148<br>V22.4.2.8<br>V22.4.2.9<br>斐讯9月18号的V22.4.5.39版本固件封堵了这种方法，配置文件和MAC一一对应<br>V22.4.5.39版本需要降级到测试版V22.4.2.8或者V22.4.2.9</p><p>V22.4.5.42 降级就可以了。</p><p>(官网9月28日已经悄悄删除，备份链接: <a href="http://code.taobao.org/svn/hopol-bak/K2/phicomm/K2/">http://code.taobao.org/svn/hopol-bak/K2/phicomm/K2/</a> )</p><p>如果是V21.4.6.12版本请下载新版手动升级，斐讯官方固件下载地址：<br><a href="http://file.soho.phicomm.com.cn/upload/k2/k2/">http://file.soho.phicomm.com.cn/upload/k2/k2/</a></p><h3 id="刷入breed和ssh"><a href="#刷入breed和ssh" class="headerlink" title="刷入breed和ssh"></a>刷入breed和ssh</h3><ol><li><p>点击下载下面的文件<br><a href="http://tianbao.sf.net/b/">tianbaoha_breed_ssh.dat</a><br>备份链接 <a href="http://code.taobao.org/svn/hopol-bak/K2/tianbaoha_breed_ssh.dat">http://code.taobao.org/svn/hopol-bak/K2/tianbaoha_breed_ssh.dat</a> 【右键另存为】</p></li><li><p> 登陆路由器<br>（默认 p.to 或者 phicomm.me 或者 192.168.2.1 ）</p></li><li><p>进入： 高级设置—-系统设置—-备份恢复—-浏览—–选择下载的tianbaoha_breed_ssh.dat—-点击恢复备份—-等待进度条完成(大约需要2分钟)。<br><img src="http://ww2.sinaimg.cn/large/723b2af4gw1fasjwdxroqj208c05gaad.jpg"><br><img src="http://ww1.sinaimg.cn/large/723b2af4gw1fasjx2w28gj208c04daa3.jpg"></p></li><li><p>重启以后使用新的管理密码：tianbaoha 登陆，如果登陆成功就说明breed和ssh刷好了。<br><img src="http://ww4.sinaimg.cn/large/723b2af4jw1fasjxl4vo9j208c05ijrc.jpg"></p></li><li><p>进入 ：高级设置—-系统设置—-手动升级—-按图所示 点击下载备份EEPROM<br><img src="http://ww3.sinaimg.cn/large/723b2af4jw1fasjxvurgqj208c059mxe.jpg"></p></li></ol><p>如果继续使用斐讯固件自己改个密码就行了，如果想刷第三方固件就：<br>点击 浏览—–选择需要刷入的固件—-点击升级即可。<br>在下使用的是这个华硕固件：<a href="http://www.right.com.cn/forum/thread-161324-1-1.html">http://www.right.com.cn/forum/thread-161324-1-1.html</a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>默认开启了telnet检测开关，使用斐讯固件的话恢复出厂或升级新版telnet也不会关闭。</p></li><li><p>第三方固件的管理地址 因固件而异，比如hiyboy编译的华硕padavan是192.168.123.1，可以根据获取到的IP判断。<br>刷了不同版本的固件或者第三方固件时，清除一下浏览器缓存文件，推荐使用Chromium内核的或者Firefox浏览器。</p></li><li><p>路由的指示灯是由固件控制的，有的第三方固件没有适配造成显示不正常（比如红灯长亮），不必惊慌，能正常使用固件，没有任何其他副作用，强迫症除外。</p></li><li><p>需要可用空间大于170KB，如果你以前装软件装满了请恢复出厂设置。</p></li><li><p>支持上传刷入默认50000分区的固件(比如潘多拉、华硕padavan)，上传官网下载的新版固件不会覆盖breed，会保留当前版本配置。<br>如果你上传了错误的固件或者压缩包会卡在breed界面，需要自己手动进breed重新刷。</p></li></ol><h3 id="进入breed方法"><a href="#进入breed方法" class="headerlink" title="进入breed方法"></a>进入breed方法</h3><p>路由WAN口的网线拔掉，电脑网线连接路由LAN口，电脑网卡设置为自动获取IP:<br>路由断电3秒—-按住复位键不要松手—-插入电源—-等待5秒松手—-浏览器输入192.168.1.1—-固件更新—-选择固件刷入。<br>breed作者原帖：<a href="http://www.right.com.cn/forum/thread-161906-1-1.html">http://www.right.com.cn/forum/thread-161906-1-1.html</a><br>中文版PuTTy：<a href="https://github.com/larryli/PuTTY">https://github.com/larryli/PuTTY</a></p>]]></content>
    
    
    <categories>
      
      <category>玩机教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破解高德SDK实现免key</title>
    <link href="/2016/09/10/%C3%86%C3%86%C2%BDa%CC%82%C2%B8%C3%9F%C2%B5A%CC%82SDKE%CC%82%C2%B5I%CC%88O%CC%88A%CC%83a%CC%82key/"/>
    <url>/2016/09/10/%C3%86%C3%86%C2%BDa%CC%82%C2%B8%C3%9F%C2%B5A%CC%82SDKE%CC%82%C2%B5I%CC%88O%CC%88A%CC%83a%CC%82key/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个 Android 开发者，使用定位 SDK 越来越频繁，但是基本上所有的定位 SDK 都需要使用时申请 key ，而且这些 key 又根据签名和包名生成，作为程序员，怎么能忍受这么麻烦的事情，于是就着手想办法解决。至于为什么是高德呢，只是因为不喜欢百度。</p><a id="more"></a><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul><li>高德定位SDK最新版 AMap_Location_V2.9.0_20160906.jar</li><li>Android Studio</li><li>Java Decompiler</li></ul><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>高德的定位 SDK 在申请 key 的时候需要的信息包名和 SHA1 码，然后会给我们一个 key ，因此在校验的时候肯定也是这三个条件有：</p><ul><li>包名</li><li>编译key的SHA1码</li><li>申请得到的key</li></ul><p>那么如果我们找到高德获取这些信息的入口，申请一个key，然后将这些信息写死在代码中试试能不能做到呢？</p><p>接下来我们就来尝试一下</p><p>高德的定位 SDK 是一个 jar 包，而jar包是很容易反编译的，首先我们使用 Java Decompiler 来看一下代码结构</p><p><img src="http://ww1.sinaimg.cn/large/723b2af4gw1f7orajggdxj20am0e1taq.jpg"></p><p>看到了什么– APSService ,就是高德让我们在 AndroidManifest.xml 中声明的那个 Service ,说明这个就是高德定位的入口，来看看里面的内容</p><p><img src="http://ww4.sinaimg.cn/large/723b2af4gw1f7orax444dj20w90jxgpl.jpg"></p><p>做过动态加载的人肯定一眼就看出来了，这是一个代理 Service ，真正运行的是实现了 APSServiceBase 的 Service ，那就需要去寻找实现了 APSServiceBase 的类,反正类不多就一个一个看，就找了到 b.class</p><p><img src="http://ww2.sinaimg.cn/large/723b2af4gw1f7orb6cqgmj20nt0kjwlr.jpg"></p><p>在 onBind 方法里面我们看到了关键信息</p><p><img src="http://ww4.sinaimg.cn/large/723b2af4gw1f7orbdv1guj20ef0gutcg.jpg"></p><p>这个 onBind 是代理 APSService 的 onBind ，那我们就在 APSService 的 onBind 方法里面打印这些参数，看看分别都是什么,那怎么修改 jar 包呢，其实非常简单， jar 包就是一个 zip 格式的压缩文件，我们只需要解压替换，然后重新压缩就可以了。</p><h2 id="修改jar"><a href="#修改jar" class="headerlink" title="修改jar"></a>修改jar</h2><p>使用 Android Studio 新建一个 Android Library 的 Module ，包名与  jar 包要修改的类包名相同,新建一个类，与要修改的类名相同</p><p><img src="http://ww2.sinaimg.cn/large/723b2af4gw1f7orblt8sdj20b90bvgms.jpg"></p><p>复制反编译出来的 APSService 的内容到我们新建的类中，同时将 SDK 的 jar 包作为这个 Module 的依赖包，保证这个 Module 可以正常编译。其中 onBInd 方法我们修改为以下内容，其中修改后的内容为我们已经在高德官网申请过得 key 信息。</p><ul><li>注意：这里 sha1AndPackage 中 SHA1 码与包名中间的冒号为中文冒号，高德真是费尽心机…</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">onBind</span><span class="hljs-params">(Intent paramIntent)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        String str1 = paramIntent.getStringExtra(<span class="hljs-string">&quot;apiKey&quot;</span>);        String str2 = paramIntent.getStringExtra(<span class="hljs-string">&quot;packageName&quot;</span>);        String str3 = paramIntent.getStringExtra(<span class="hljs-string">&quot;sha1AndPackage&quot;</span>);        String str4 = paramIntent.getStringExtra(<span class="hljs-string">&quot;as&quot;</span>);        Log.i(<span class="hljs-string">&quot;修改前数据&quot;</span>, <span class="hljs-string">&quot;apiKey:&quot;</span> + str1 + <span class="hljs-string">&quot;\npackageName:&quot;</span> + str2 + <span class="hljs-string">&quot;\nsha1AndPackage:&quot;</span> + str3 + <span class="hljs-string">&quot;\nas:&quot;</span> + str4);        paramIntent.putExtra(<span class="hljs-string">&quot;apiKey&quot;</span>, <span class="hljs-string">&quot;93036c13932aba6eeaee2a02656f14d7&quot;</span>);        paramIntent.putExtra(<span class="hljs-string">&quot;packageName&quot;</span>, <span class="hljs-string">&quot;com.lge.clock&quot;</span>);        paramIntent.putExtra(<span class="hljs-string">&quot;sha1AndPackage&quot;</span>, <span class="hljs-string">&quot;FA:AB:F5:02:B2:17:AC:D3:DA:46:38:ED:FF:E3:0C:A3:E4:67:0A:50:com.lge.clock&quot;</span>);        str1 = paramIntent.getStringExtra(<span class="hljs-string">&quot;apiKey&quot;</span>);        str2 = paramIntent.getStringExtra(<span class="hljs-string">&quot;packageName&quot;</span>);        str3 = paramIntent.getStringExtra(<span class="hljs-string">&quot;sha1AndPackage&quot;</span>);        str4 = paramIntent.getStringExtra(<span class="hljs-string">&quot;as&quot;</span>);        Log.i(<span class="hljs-string">&quot;修改后数据&quot;</span>, <span class="hljs-string">&quot;apiKey:&quot;</span> + str1 + <span class="hljs-string">&quot;\npackageName:&quot;</span> + str2 + <span class="hljs-string">&quot;\nsha1AndPackage:&quot;</span> + str3 + <span class="hljs-string">&quot;\nas:&quot;</span> + str4);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a.onBind(paramIntent);    &#125; <span class="hljs-keyword">catch</span> (Throwable localThrowable) &#123;        c.a(localThrowable, <span class="hljs-string">&quot;APSService&quot;</span>, <span class="hljs-string">&quot;onBind&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>接下来只需要打包这个 Module 为 jar 包，然后提取出这个类的 class 文件，替换高德 SDK 的 jar 包中对应的 class 文件即可。</p><p>Android Studio 如何打包 jar 呢？</p><p>我们在这个修改的用来修改的 Module 的 build.gradle 中添加以下代码</p><pre><code class="hljs Groovy">task makeJar(<span class="hljs-attr">type:</span> Copy) &#123;    delete <span class="hljs-string">&#x27;build/libs/lib.jar&#x27;</span>    from(<span class="hljs-string">&#x27;build/intermediates/bundles/release/&#x27;</span>)    into(<span class="hljs-string">&#x27;build/libs/&#x27;</span>)    include(<span class="hljs-string">&#x27;classes.jar&#x27;</span>)    rename (<span class="hljs-string">&#x27;classes.jar&#x27;</span>, <span class="hljs-string">&#x27;lib.jar&#x27;</span>)&#125;makeJar.dependsOn(build)</code></pre><p>在工程目录下执行 </p><pre><code class="hljs ebnf"><span class="hljs-attribute">gradlew makeJar</span></code></pre><p><img src="http://ww4.sinaimg.cn/large/723b2af4gw1f7orvm9vo2j20s80a9769.jpg"></p><p>即可得到 jar 文件</p><p><img src="http://ww2.sinaimg.cn/large/723b2af4gw1f7orx6ytocj20ak0efjsf.jpg"></p><p>解压 lib.jar 和 高德 SDK 的 jar，使用 lib.jar 中的 APSService.class 替换高德 SDK 中的 APSService.class ,然后将这个文件夹重新<strong>压缩成 zip格式</strong> ,然后修改扩展名为 .jar 即可。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>使用修改后的 SDK jar 包替换原来的 jar 包进行定位测试，不要忘了在 AndroidManifest.xml 也加上申请好的 key 。</p><p>测试结果为可以正常定位，包名和签名可以随意换咯，再也不用麻烦的每次申请 key 啦！</p><h2 id="国际惯例"><a href="#国际惯例" class="headerlink" title="国际惯例"></a>国际惯例</h2><p>奉上源代码</p><pre><code class="hljs url">https:&#x2F;&#x2F;github.com&#x2F;YiuChoi&#x2F;CrackAmap</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Xposed问题笔记</title>
    <link href="/2016/08/25/XposedI%CC%82E%CC%82I%CC%80a%CC%82%C2%B1E%CC%82%C2%BCC%CC%A7/"/>
    <url>/2016/08/25/XposedI%CC%82E%CC%82I%CC%80a%CC%82%C2%B1E%CC%82%C2%BCC%CC%A7/</url>
    
    <content type="html"><![CDATA[<p>在开发xposed插件的过程中遇到的一些问题及解决办法</p><a id="more"></a><h2 id="Android-4-4以下版本出现ClassNotFound"><a href="#Android-4-4以下版本出现ClassNotFound" class="headerlink" title="Android 4.4以下版本出现ClassNotFound"></a>Android 4.4以下版本出现ClassNotFound</h2><p>主要是Xposed不支持4.4以下也就是Dalvik虚拟机multiDex</p><p>可使用以下办法：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.KITKAT_WATCH) &#123;    findAndHookMethod(Application.class, <span class="hljs-string">&quot;dispatchActivityResumed&quot;</span>, Activity.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;           XposedBridge.log(<span class="hljs-string">&quot;activity class:&quot;</span> + ((Activity) param.args[<span class="hljs-number">0</span>]).getClass());         &#125;     &#125;);&#125;</code></pre><h2 id="Android-4-4以下获取Context为null的问题"><a href="#Android-4-4以下获取Context为null的问题" class="headerlink" title="Android 4.4以下获取Context为null的问题"></a>Android 4.4以下获取Context为null的问题</h2><p>Android 4.4以下使用以下方法无法获取Context</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (loadPackageParam.packageName.equals(<span class="hljs-string">&quot;android&quot;</span>)) &#123;        <span class="hljs-keyword">final</span> Object activityThread = XposedHelpers.callStaticMethod(XposedHelpers.findClass(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>, <span class="hljs-keyword">null</span>), <span class="hljs-string">&quot;currentActivityThread&quot;</span>);        <span class="hljs-keyword">final</span> Context systemContext = (Context) XposedHelpers.callMethod(activityThread, <span class="hljs-string">&quot;getSystemContext&quot;</span>);</code></pre><p>因此使用以下方法寻找类中的Context变量获取</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (loadPackageParam.packageName.equals(<span class="hljs-string">&quot;android&quot;</span>)) &#123;    <span class="hljs-keyword">final</span> Class&lt;?&gt; phoneWindowManager;    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;        phoneWindowManager = XposedHelpers.findClass(<span class="hljs-string">&quot;com.android.server.policy.PhoneWindowManager&quot;</span>, loadPackageParam.classLoader);    &#125; <span class="hljs-keyword">else</span> &#123;        phoneWindowManager = XposedHelpers.findClass(<span class="hljs-string">&quot;com.android.internal.policy.impl.PhoneWindowManager&quot;</span>, loadPackageParam.classLoader);    &#125;    XposedBridge.hookAllMethods(phoneWindowManager, <span class="hljs-string">&quot;interceptKeyBeforeQueueing&quot;</span>, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;            <span class="hljs-keyword">int</span> v1 = ((KeyEvent) param.args[<span class="hljs-number">0</span>]).getKeyCode();            Field contextField = XposedHelpers.findField(phoneWindowManager, <span class="hljs-string">&quot;mContext&quot;</span>);            contextField.setAccessible(<span class="hljs-keyword">true</span>);            <span class="hljs-keyword">final</span> Context context = (Context) contextField.get(param.thisObject);        &#125;    &#125;);&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>xposed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义Android-Studio工程模板</title>
    <link href="/2016/08/23/%C3%97O%CC%82%C2%B6%C2%A8O%CC%80a%CC%8AAndroid-StudioA%CC%88%C2%A3%C2%B0a%CC%8A/"/>
    <url>/2016/08/23/%C3%97O%CC%82%C2%B6%C2%A8O%CC%80a%CC%8AAndroid-StudioA%CC%88%C2%A3%C2%B0a%CC%8A/</url>
    
    <content type="html"><![CDATA[<p>每次创建新的Android Studio工程时，都需要手动修改一些工程的配置，<br>比如删除不必要的依赖、删掉Activity中不必要的代码 配置私有maven库的地址、增加公用的依赖库、修改.gitingore、关闭lint的严格检查、配置APK的输出路径等等,当有很多类似的项目的时候就有大量的无用功，<br>浪费时间，就可以考虑修改Android Studio默认的project和module模板。</p><a id="more"></a><h2 id="默认模板路径"><a href="#默认模板路径" class="headerlink" title="默认模板路径"></a>默认模板路径</h2><p>Android Studio的工程模板在安装目录的“\plugins\android\lib\templates\gradle-projects”文件夹下，这里面包含了导入工程模板、新建工程模板、新建module模板等。</p><p>![](/images/template path.png)</p><h2 id="模板的文件结构"><a href="#模板的文件结构" class="headerlink" title="模板的文件结构"></a>模板的文件结构</h2><p>学习编写模板最好的方式就是参考Android Studio中已经提供的最简单的模板，那么在Android Studio中最简单的activity模板就是:Empty Activity了，我们打开该模板文件，首先对文件结构有个直观的了解，如图：</p><p>![](/images/empty activity.png)</p><p>文件夹包含</p><ul><li>template.xml</li><li>globals.xml.ftl</li><li>recipe.xml.ftl</li><li>root文件夹 存放对应源码的ftl文件，以及资源文件</li><li>效果缩略图</li></ul><p>下面我们逐一对上述每个文件的作用就行介绍。</p><h3 id="template-xml"><a href="#template-xml" class="headerlink" title="template.xml"></a>template.xml</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span></span><span class="hljs-tag">    <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;5&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">revision</span>=<span class="hljs-string">&quot;5&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Empty Activity&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">minApi</span>=<span class="hljs-string">&quot;9&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">minBuildApi</span>=<span class="hljs-string">&quot;14&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">description</span>=<span class="hljs-string">&quot;Creates a new empty activity&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Activity&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">formfactor</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mobile&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parameter</span></span><span class="hljs-tag">        <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;activityClass&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Activity Name&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">constraints</span>=<span class="hljs-string">&quot;class|unique|nonempty&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">suggest</span>=<span class="hljs-string">&quot;$&#123;layoutToActivity(layoutName)&#125;&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;MainActivity&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">help</span>=<span class="hljs-string">&quot;The name of the activity class to create&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parameter</span></span><span class="hljs-tag">        <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;generateLayout&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Generate Layout File&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boolean&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">help</span>=<span class="hljs-string">&quot;If true, a layout file will be generated&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parameter</span></span><span class="hljs-tag">        <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;layoutName&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Layout Name&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">constraints</span>=<span class="hljs-string">&quot;layout|unique|nonempty&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">suggest</span>=<span class="hljs-string">&quot;$&#123;activityToLayout(activityClass)&#125;&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;activity_main&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">visibility</span>=<span class="hljs-string">&quot;generateLayout&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">help</span>=<span class="hljs-string">&quot;The name of the layout to create for the activity&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parameter</span></span><span class="hljs-tag">        <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;isLauncher&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Launcher Activity&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boolean&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;false&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">help</span>=<span class="hljs-string">&quot;If true, this activity will have a CATEGORY_LAUNCHER intent filter, making it visible in the launcher&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parameter</span></span><span class="hljs-tag">        <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;backwardsCompatibility&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Backwards Compatibility (AppCompat)&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boolean&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">help</span>=<span class="hljs-string">&quot;If false, this activity base class will be Activity instead of AppCompatActivity&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parameter</span></span><span class="hljs-tag">        <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;packageName&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Package name&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">constraints</span>=<span class="hljs-string">&quot;package&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;com.mycompany.myapp&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 128x128 thumbnails relative to template.xml --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">thumbs</span>&gt;</span>        <span class="hljs-comment">&lt;!-- default thumbnail is required --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">thumb</span>&gt;</span>template_blank_activity.png<span class="hljs-tag">&lt;/<span class="hljs-name">thumb</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">thumbs</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">globals</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;globals.xml.ftl&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">execute</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;recipe.xml.ftl&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre><p>其中</p><ul><li><p>template中的name属性，对应新建Activity时显示的名字</p></li><li><p>category对应New的类别为Activity</p></li></ul><p>剩下的，对应我们AndroidStudio新建Empty Activity的界面就非常好理解了，如图：</p><p>![](/images/empty thumbnail.png)</p><p>看到这个界面，大部分属性都应该能才出来了，我们重点看parameter，界面上每一个紫色框出来的部分都对应一个parameter，部分属性介绍：</p><ul><li>id ：唯一标识，最终通过该属性的值，获取用户输入值（文本框内容，是否选中）</li><li>name：界面上的类似label的提示语</li><li>type : 输入值类型</li><li>constraints：填写值的约束</li><li>suggest：建议值，比如填写ActivityName的时候，会给出一个布局文件的建议值。</li><li>default:默认值</li><li>help:底部显示的提升语</li></ul><p>这个部分对应界面还是非常好理解的，大家可以简单的修改一些字符串，或者添加一个parameter，重启AS，看看效果。</p><p>template.xml的最下面的部分引入了globals.xml.ftl和recipe.xml.ftl。</p><p>这两个我们会详细介绍。</p><h3 id="globals-xml-ftl"><a href="#globals-xml-ftl" class="headerlink" title="globals.xml.ftl"></a>globals.xml.ftl</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">globals</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">global</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hasNoActionBar&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boolean&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">global</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parentActivityClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">global</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simpleLayoutName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;layoutName&#125;&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">global</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;excludeMenu&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boolean&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">global</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;generateActivityTitle&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boolean&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">#include</span> &quot;<span class="hljs-attr">..</span>/<span class="hljs-attr">common</span>/<span class="hljs-attr">common_globals.xml.ftl</span>&quot; /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">globals</span>&gt;</span></code></pre><p>通过名称可以猜到它是用于定义一些全局的变量，可以看到其内部有global标签，分别定义id,type,默认值。</p><p>同理，我们可以通过id的值访问到该值，例如：</p><p>${hasNoActionBar}的值为false。</p><h3 id="recipe-xml-ftl"><a href="#recipe-xml-ftl" class="headerlink" title="recipe.xml.ftl"></a>recipe.xml.ftl</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">recipe</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">#include</span> &quot;<span class="hljs-attr">..</span>/<span class="hljs-attr">common</span>/<span class="hljs-attr">recipe_manifest.xml.ftl</span>&quot; /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">generateLayout</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">#include</span> &quot;<span class="hljs-attr">..</span>/<span class="hljs-attr">common</span>/<span class="hljs-attr">recipe_simple.xml.ftl</span>&quot; /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">open</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">instantiate</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&quot;root/src/app_package/SimpleActivity.java.ftl&quot;</span></span><span class="hljs-tag">                   <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">open</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">recipe</span>&gt;</span></code></pre><p>为了介绍，我将该xml中比较重要的几个标签都列出来了：</p><ul><li>copy :从root中copy文件到我们的目标目录，比如我们的模板Activity需要使用一些图标，那么可能就需要使用copy标签将这些图标拷贝到我们的项目对应文件夹。</li><li>merge : 合并的意思，比如将我们使用到的strings.xml合并到我们的项目的stirngs.xml中</li><li>instantiate : 和copy类似，但是可以看到上例试将ftl-&gt;java文件的，也就是说中间会通过一个步骤，将ftl中的变量都换成对应的值，那么完整的流程是ftl-&gt;freemarker process -&gt; java。</li><li>open:在代码生成后，打开指定的文件，比如我们新建一个Activity后，默认就会将该Activity打开。</li></ul><p>在介绍instantiate时，涉及到了freemarker，不可避免的需要对它进行简单的介绍。</p><p>目前我们已经基本了解了一个模板其内部的文件结构了，以及每个文件大致包含的东西，我们简单做个总结：</p><ul><li>template 中parameter标签，主要用于提供参数</li><li>global.xml.ftl 主要用于提供参数</li><li>recipe.xml.ftl 主要用于生成我们实际需要的代码，资源文件等；例如，利用参数+MainActivity.java.ftl -&gt; MainActivity.java；其实就是利用参数将ftl中的变量进行替换。<h2 id="简单的freemarker语法"><a href="#简单的freemarker语法" class="headerlink" title="简单的freemarker语法"></a>简单的freemarker语法</h2></li></ul><p>上面我们已经基本了解模板生成的大致的流程以及涉及到的文件，大致了解了我们生成的源码或者xml文件，需要经过：</p><pre><code class="hljs xml">ftl-&gt;freemarker process-&gt;java/xml</code></pre><p>这样的流程，那么我们必须对freemarker有个简单的了解。</p><ul><li>非常简单的例子</li></ul><p>比如我们有个变量user=zhy；<br>有个ftl文件内容：helloL${user}<br>最后经过freemarker的输出结果即为 hello:zhy</p><ul><li>if语法</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">generateLayout</span>&gt;</span>    //生成layout文件<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></code></pre><p>看一眼就知道大概的意思了~有一定的编程经验，即使不知道这个叫freemarker，对于这些简单的语法还是能看懂的。</p><p>我们最后以Empty Activity模板的中的SimpleActivity为例：</p><p>root/src/app_package/SimpleActivity.java.ftl</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> $&#123;packageName&#125;;<span class="hljs-keyword">import</span> $&#123;superClassFqcn&#125;;<span class="hljs-keyword">import</span> android.os.Bundle;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $</span>&#123;activityClass&#125; extends $&#123;superClass&#125; &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);&lt;#if generateLayout&gt;        setContentView(R.layout.$&#123;layoutName&#125;);&lt;/#if&gt;    &#125;&#125;</code></pre><p>可以看到其内部包含很多变量，这些变量的值一般来源于用户输入和global.xml.ftl中预定义的值，经过recipe.xml.ftl中instantiate标签的处理，将变量换成实际的值，即可在我们的项目的指定位置，得到我们期望的Activity。</p><h2 id="具体的模板实例"><a href="#具体的模板实例" class="headerlink" title="具体的模板实例"></a>具体的模板实例</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React-Native学习（1）</title>
    <link href="/2016/08/22/React-NativeN%CC%83%C2%A7I%CC%88%C2%B0%C2%A3%C2%A81%C2%A3%C2%A9/"/>
    <url>/2016/08/22/React-NativeN%CC%83%C2%A7I%CC%88%C2%B0%C2%A3%C2%A81%C2%A3%C2%A9/</url>
    
    <content type="html"><![CDATA[<p>React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。</p><p>React Native着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。(Learn once, write anywhere)</p><p>Facebook已经在多项产品中使用了React Native，并且将持续地投入建设React Native。</p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><a href="http://reactnative.cn/docs/0.31/getting-started.html#content">官方环境搭建教程中文版</a></p><h2 id="淘宝npm镜像"><a href="#淘宝npm镜像" class="headerlink" title="淘宝npm镜像"></a>淘宝npm镜像</h2><p>镜像使用方法（三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）:</p><ol><li><p>通过config命令<br>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>npm info underscore （如果上面配置正确这个命令会有字符串response）</p></li><li><p>命令行指定<br>npm –registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> info underscore </p></li><li><p>编辑 ~/.npmrc 加入下面内容<br>registry = <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></li></ol><h2 id="使用Visual-Code开发React-Native"><a href="#使用Visual-Code开发React-Native" class="headerlink" title="使用Visual Code开发React Native"></a>使用Visual Code开发React Native</h2><ol><li><p>在VS Code中安装扩展(0.10.8+)-插件地址:<a href="https://github.com/Microsoft/vscode-react-native">https://github.com/Microsoft/vscode-react-native</a></p><p> 该扩展工具(React Native Tools)给React Native项目提供了一个开发环境。你可以调试你的代码、通过命令面板终端快速的运行react-native命令、并且支持代码智能补全,对象搜索浏览、方法、参数以及其他一些React Native  API。</p></li><li><p>使用VS Code通过React Native的根目录进行打开</p></li><li><p>在菜单中点击调试图标 ,然后点击configure齿轮样子的图标来选择React Native调试环境</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>React Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux使用sqlcipher解密sqlite</title>
    <link href="/2016/08/17/linuxE%CC%82%C2%B9O%CC%81A%CC%83sqlcipher%C2%BDa%CC%82A%CC%83U%CC%88sqlite/"/>
    <url>/2016/08/17/linuxE%CC%82%C2%B9O%CC%81A%CC%83sqlcipher%C2%BDa%CC%82A%CC%83U%CC%88sqlite/</url>
    
    <content type="html"><![CDATA[<p>微信数据库便是使用这种加密方式，因此可以用来解密微信数据库</p><a id="more"></a><h2 id="安装sqlicipher"><a href="#安装sqlicipher" class="headerlink" title="安装sqlicipher"></a>安装sqlicipher</h2><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><pre><code class="hljs sh">apt-get install sqlcipher</code></pre><h3 id="使用源码编译"><a href="#使用源码编译" class="headerlink" title="使用源码编译"></a>使用源码编译</h3><h4 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h4><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/sqlcipher/sqlcipher.git</code></pre><h4 id="定义-SQLITE-HAS-CODEC和SQLITE-TEMP-STORE-2"><a href="#定义-SQLITE-HAS-CODEC和SQLITE-TEMP-STORE-2" class="headerlink" title="定义 SQLITE_HAS_CODEC和SQLITE_TEMP_STORE=2"></a>定义 SQLITE_HAS_CODEC和SQLITE_TEMP_STORE=2</h4><pre><code class="hljs sh"><span class="hljs-built_in">export</span> SQLITE_HAS_CODEC<span class="hljs-built_in">export</span> SQLITE_TEMP_STORE=2</code></pre><h4 id="安装openssl和tcl"><a href="#安装openssl和tcl" class="headerlink" title="安装openssl和tcl"></a>安装openssl和tcl</h4><pre><code class="hljs sh">sudo yum install opensslsudo yum install tcl</code></pre><h4 id="进入sqlcipher源码目录进行编译"><a href="#进入sqlcipher源码目录进行编译" class="headerlink" title="进入sqlcipher源码目录进行编译"></a>进入sqlcipher源码目录进行编译</h4><pre><code class="hljs sh">./configure --enable-tempstore=yes CFLAGS=<span class="hljs-string">&quot;-DSQLITE_HAS_CODEC&quot;</span> LDFLAGS=<span class="hljs-string">&quot;-lcrypto&quot;</span>makemake install</code></pre><h4 id="编译成功"><a href="#编译成功" class="headerlink" title="编译成功"></a>编译成功</h4><pre><code class="hljs sh">[root@localhost sqlcipher]<span class="hljs-comment"># sqlcipher --version</span>3.11.0 2016-02-15 17:29:24 3d862f207e3adc00f78066799ac5a8c282430a5f</code></pre><h2 id="解密sqlite文件"><a href="#解密sqlite文件" class="headerlink" title="解密sqlite文件"></a>解密sqlite文件</h2><pre><code class="hljs sql">sqlcipher EnMicroMsg.db &#x27;<span class="hljs-keyword">PRAGMA</span> <span class="hljs-keyword">key</span> = <span class="hljs-string">&quot;key&quot;</span>; <span class="hljs-keyword">PRAGMA</span> cipher_use_hmac = <span class="hljs-keyword">off</span>; <span class="hljs-keyword">PRAGMA</span> kdf_iter = <span class="hljs-number">4000</span>; ATTACH DATABASE &quot;decrypted_database.db&quot; AS decrypted_database KEY &quot;&quot;;<span class="hljs-keyword">SELECT</span> sqlcipher_export(<span class="hljs-string">&quot;decrypted_database&quot;</span>);DETACH DATABASE decrypted_database;&#x27;</code></pre><p>或者</p><pre><code class="hljs sql">sqlcipher EnMicroMsg.db &#x27;<span class="hljs-keyword">PRAGMA</span> <span class="hljs-keyword">key</span> = <span class="hljs-string">&quot;key&quot;</span>; <span class="hljs-keyword">PRAGMA</span> cipher_migrate; ATTACH DATABASE &quot;decrypted_database.db&quot; AS decrypted_database KEY &quot;&quot;;<span class="hljs-keyword">SELECT</span> sqlcipher_export(<span class="hljs-string">&quot;decrypted_database&quot;</span>);DETACH DATABASE decrypted_database;&#x27;</code></pre><p>解密得到可用sqlite3打开的decrypted_database.db。</p>]]></content>
    
    
    <categories>
      
      <category>安全攻防</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 6.0运行时权限小结</title>
    <link href="/2016/03/02/Android-6-0O%CC%82E%CC%88%C3%90%C3%90E%CC%82%C2%B1E%CC%80%C2%A8I%CC%88%C3%9E%C3%90%C2%A1%C2%BDa%CC%81/"/>
    <url>/2016/03/02/Android-6-0O%CC%82E%CC%88%C3%90%C3%90E%CC%82%C2%B1E%CC%80%C2%A8I%CC%88%C3%9E%C3%90%C2%A1%C2%BDa%CC%81/</url>
    
    <content type="html"><![CDATA[<p>Android 6.0之后需要动态申请权限</p><a id="more"></a><h2 id="Android6-0权限介绍"><a href="#Android6-0权限介绍" class="headerlink" title="Android6.0权限介绍"></a>Android6.0权限介绍</h2><p>Google在Android6.0系统之后对权限进行了分类:</p><ul><li><p>正常(Normal Protection)权限:</p><pre><code class="hljs java">ACCESS_LOCATION_EXTRA_COMMANDSACCESS_NETWORK_STATEACCESS_NOTIFICATION_POLICYACCESS_WIFI_STATEBLUETOOTHBLUETOOTH_ADMINBROADCAST_STICKYCHANGE_NETWORK_STATECHANGE_WIFI_MULTICAST_STATECHANGE_WIFI_STATEDISABLE_KEYGUARDEXPAND_STATUS_BARGET_PACKAGE_SIZEINTERNETKILL_BACKGROUND_PROCESSESMODIFY_AUDIO_SETTINGSNFCREAD_SYNC_SETTINGSREAD_SYNC_STATSRECEIVE_BOOT_COMPLETEDREORDER_TASKSREQUEST_INSTALL_PACKAGESSET_TIME_ZONESET_WALLPAPERSET_WALLPAPER_HINTSTRANSMIT_IRUSE_FINGERPRINTVIBRATEWAKE_LOCKWRITE_SYNC_SETTINGSSET_ALARMINSTALL_SHORTCUTUNINSTALL_SHORTCUT</code></pre></li><li><p>危险(Dangerous)权限</p><pre><code class="hljs java">CALENDARCAMERACONTACTSLOCATIONMICROPHONEPHONESENSORSSMSSTORAGE</code></pre><p>权限分组及其具体权限如下:<br><img src="http://ww4.sinaimg.cn/large/6a195423jw1ezwpc11cs0j20hr0majwm.jpg" alt="此处输入图片的描述"></p></li><li><p>特殊(Particular)权限</p><pre><code class="hljs java">SYSTEM_ALERT_WINDOW，设置悬浮窗WRITE_SETTINGS 修改系统设置</code></pre></li><li><p>其他权限（一般很少用到）</p></li></ul><p>Android6.0在之前AndroidManifest.xml声明权限的基础上对危险权限和特殊权限新增了运行时权限，需要动态获取权限。</p><h2 id="运行时权限处理"><a href="#运行时权限处理" class="headerlink" title="运行时权限处理"></a>运行时权限处理</h2><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>特殊权限的做法是使用startResultActivity启动授权界面来完成。</p><h4 id="请求SYSTEM-ALERT-WINDOW权限"><a href="#请求SYSTEM-ALERT-WINDOW权限" class="headerlink" title="请求SYSTEM_ALERT_WINDOW权限"></a>请求SYSTEM_ALERT_WINDOW权限</h4><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REQUEST_CODE = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">requestAlertWindowPermission</span><span class="hljs-params">()</span> </span>&#123;    Intent intent = <span class="hljs-keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);    intent.setData(Uri.parse(<span class="hljs-string">&quot;package:&quot;</span> + getPackageName()));    startActivityForResult(intent, REQUEST_CODE);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> resultCode, Intent data)</span> </span>&#123;    <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, data);    <span class="hljs-keyword">if</span> (requestCode == REQUEST_CODE) &#123;        <span class="hljs-keyword">if</span> (Settings.canDrawOverlays(<span class="hljs-keyword">this</span>)) &#123;          Log.i(LOGTAG, <span class="hljs-string">&quot;onActivityResult granted&quot;</span>);        &#125;    &#125;&#125;</code></pre><p>上述代码需要注意的是</p><ul><li><p>使用Action Settings.ACTION_MANAGE_OVERLAY_PERMISSION启动隐式Intent</p></li><li><p>使用”package:” + getPackageName()携带App的包名信息</p></li><li><p>使用Settings.canDrawOverlays方法判断授权结果</p><h4 id="请求WRITE-SETTINGS"><a href="#请求WRITE-SETTINGS" class="headerlink" title="请求WRITE_SETTINGS"></a>请求WRITE_SETTINGS</h4><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REQUEST_CODE_WRITE_SETTINGS = <span class="hljs-number">2</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestWriteSettings</span><span class="hljs-params">()</span> </span>&#123;    Intent intent = <span class="hljs-keyword">new</span> Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS);    intent.setData(Uri.parse(<span class="hljs-string">&quot;package:&quot;</span> + getPackageName()));    startActivityForResult(intent, REQUEST_CODE_WRITE_SETTINGS );&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> resultCode, Intent data)</span> </span>&#123;    <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, data);    <span class="hljs-keyword">if</span> (requestCode == REQUEST_CODE_WRITE_SETTINGS) &#123;        <span class="hljs-keyword">if</span> (Settings.System.canWrite(<span class="hljs-keyword">this</span>)) &#123;            Log.i(LOGTAG, <span class="hljs-string">&quot;onActivityResult write settings granted&quot;</span> );        &#125;    &#125;&#125;</code></pre><p>上述代码需要注意的是</p></li><li><p>使用Action Settings.ACTION_MANAGE_WRITE_SETTINGS启动隐式Intent</p></li><li><p>使用”package:” + getPackageName()携带App的包名信息</p></li><li><p>使用Settings.canDrawOverlays方法判断授权结果</p><h3 id="危险权限"><a href="#危险权限" class="headerlink" title="危险权限"></a>危险权限</h3><p>我们需要使用以下API：</p></li><li><p>int checkSelfPermission(String permission) 用来检测应用是否已经具有权限</p></li><li><p>void requestPermissions(String[] permissions, int requestCode) 进行请求单个或多个权限</p></li><li><p>void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) 用户对请求作出响应后的回调<br>以请求READ_EXTERNAL_STORAGE权限为例:</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> READ_EXTERNAL_STORAGE_REQUEST_CODE = <span class="hljs-number">1</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;    <span class="hljs-keyword">if</span> (ContextCompat.checkSelfPermission(MainActivity.<span class="hljs-keyword">this</span>, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;      ActivityCompat.requestPermissions(MainActivity.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;,    READ_EXTERNAL_STORAGE_REQUEST_CODE);   &#125;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRequestPermissionsResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, String[] permissions, <span class="hljs-keyword">int</span>[] grantResults)</span> </span>&#123;    <span class="hljs-keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);    <span class="hljs-keyword">if</span> (requestCode == READ_EXTERNAL_STORAGE_REQUEST_CODE)&#123;       <span class="hljs-keyword">if</span> (grantResults[<span class="hljs-number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;        Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_PICK, <span class="hljs-keyword">null</span>);        intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, IMAGE_TYPE);        startActivityForResult(intent, RESULT_IMAGE);        &#125;<span class="hljs-keyword">else</span>&#123;            Snackbar.make(recyclerView,<span class="hljs-string">&quot;没有权限臣妾做不到呀&quot;</span>,Snackbar.LENGTH_INDEFINITE).setAction(<span class="hljs-string">&quot;再次获取权限&quot;</span>, <span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;            ActivityCompat.requestPermissions(MainActivity.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, READ_EXTERNAL_STORAGE_REQUEST_CODE);               &#125;          &#125;);      &#125;   &#125;&#125;</code></pre><p>请求权限后，系统会弹出请求权限的Dialog<br><img src="http://7xjq5l.com1.z0.glb.clouddn.com/18501-06bc037ab77c9c62.png" alt="此处输入图片的描述"><br>当用户选择允许或拒绝，我们就可以在onRequestPermissionsResult方法中进行响应的处理，如果用户拒绝，应用再次申请权限将会出现不在询问的选项：<br><img src="http://ww1.sinaimg.cn/large/6a195423jw1ezwtz1ljjgj20u01hcad8.jpg" alt="此处输入图片的描述"><br>当用户勾选了”不再询问“拒绝后，应用的这个权限就无法使用了。<br>不过，你还有一丝希望，那就是再出现上述的对话框之前做一些说明信息，比如你使用这个权限的目的（一定要坦白）。</p></li></ul><p>shouldShowRequestPermissionRationale这个API可以帮我们判断接下来的对话框是否包含”不再询问“选择框。因此，一个标准的申请权限流程如下:</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!(checkSelfPermission(Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED)) &#123;  <span class="hljs-keyword">if</span> (shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) &#123;      Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;Please grant the permission this time&quot;</span>, Toast.LENGTH_LONG).show();    &#125;    requestReadContactsPermission();&#125; <span class="hljs-keyword">else</span> &#123;  Log.i(LOGTAG, <span class="hljs-string">&quot;onClick granted&quot;</span>);&#125;</code></pre><h4 id="批量申请权限"><a href="#批量申请权限" class="headerlink" title="批量申请权限"></a>批量申请权限</h4><p>只需要字符串数组放置多个权限即可：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REQUEST_CODE = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestMultiplePermissions</span><span class="hljs-params">()</span> </span>&#123;    String[] permissions = &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE&#125;;    requestPermissions(permissions, REQUEST_CODE);&#125;</code></pre><p><img src="http://ww2.sinaimg.cn/large/6a195423jw1ezxulzbeu2j20iq0ggt9y.jpg" alt="此处输入图片的描述"></p><h4 id="权限很多呢"><a href="#权限很多呢" class="headerlink" title="权限很多呢"></a>权限很多呢</h4><p>前面权限介绍已经提到了权限分组，举一个例子，如果你的应用授权了读取联系人的权限，那么你的应用也是被赋予了写入联系人的权限。因为读取联系人和写入联系人这两个权限都属于联系人权限分组，所以一旦组内某个权限被允许，该组的其他权限也是被允许的。</p><h3 id="Fragment中运行时权限的特殊处理"><a href="#Fragment中运行时权限的特殊处理" class="headerlink" title="Fragment中运行时权限的特殊处理"></a>Fragment中运行时权限的特殊处理</h3><ul><li>在Fragment中申请权限，不要使用ActivityCompat.requestPermissions, 直接使用Fragment的requestPermissions方法，否则会回调到Activity的onRequestPermissionsResult</li><li>如果在Fragment中嵌套Fragment，在子Fragment中使用requestPermissions方法，onRequestPermissionsResult不会回调回来，建议使用getParentFragment().requestPermissions方法，<br>这个方法会回调到父Fragment中的onRequestPermissionsResult，加入以下代码可以把回调透传到子Fragment<pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRequestPermissionsResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, String[] permissions, <span class="hljs-keyword">int</span>[] grantResults)</span> </span>&#123;    <span class="hljs-keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);    List&lt;Fragment&gt; fragments = getChildFragmentManager().getFragments();    <span class="hljs-keyword">if</span> (fragments != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (Fragment fragment : fragments) &#123;            <span class="hljs-keyword">if</span> (fragment != <span class="hljs-keyword">null</span>) &#123;                fragment.onRequestPermissionsResult(requestCode,permissions,grantResults);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3>即使支持了运行时权限，也要在Manifest声明，因为市场应用会根据这个信息和硬件设备进行匹配，决定你的应用是否在该设备上显示。</li></ul><h2 id="相关开源项目"><a href="#相关开源项目" class="headerlink" title="相关开源项目"></a>相关开源项目</h2><ul><li><a href="https://github.com/hotchemi/PermissionsDispatcher">PermissionsDispatcher</a><br>使用标注的方式，动态生成类处理运行时权限，目前还不支持嵌套Fragment。</li><li><a href="https://github.com/tbruyelle/RxPermissions">RxPermissions</a><br>基于RxJava的运行时权限检测框架</li><li><a href="https://github.com/anthonycr/Grant">Grant</a><br>简化运行时权限的处理，比较灵活</li><li><a href="https://github.com/googlesamples/android-RuntimePermissions">android-RuntimePermissions</a><br>Google官方的例子</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android运行时权限</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android直接连接mysql数据库</title>
    <link href="/2016/02/04/androidO%CC%88%C2%B1%C2%BDO%CC%81A%CC%81%C2%AC%C2%BDO%CC%81mysqlE%CC%82y%CC%81%C2%BEY%CC%81%C2%BFa%CC%82/"/>
    <url>/2016/02/04/androidO%CC%88%C2%B1%C2%BDO%CC%81A%CC%81%C2%AC%C2%BDO%CC%81mysqlE%CC%82y%CC%81%C2%BEY%CC%81%C2%BFa%CC%82/</url>
    
    <content type="html"><![CDATA[<p>理论上讲，android不应该直接连接数据库的，但是处于业务需要，且自己局域网使用，不存在泄漏问题，所以就尝试了android直接连接mysql数据库<br>首先，需要网络连接权限，这就不说了，然后添加mysql连接依赖包：</p><pre><code class="hljs java">compile <span class="hljs-string">&#x27;mysql:mysql-connector-java:5.1.18&#x27;</span></code></pre><p>最后下面这段代码即可连接成功,记得在异步线程执行。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>&#123;       Connection connection = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;           Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>).newInstance();           String url = <span class="hljs-string">&quot;jdbc:mysql://192.168.1.1:3306/database_name&quot;</span>;           connection = (Connection) DriverManager.getConnection(url, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);           Statement statement = (Statement) connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);           String sql = <span class="hljs-string">&quot;select * from table_name&quot;</span>;           ResultSet resultSet = statement.executeQuery(sql);           <span class="hljs-keyword">while</span> (resultSet.next()) &#123;               Log.i(<span class="hljs-string">&quot;TAG&quot;</span>, resultSet.getString(<span class="hljs-string">&quot;content&quot;</span>));           &#125;       &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | SQLException | InstantiationException | IllegalAccessException e) &#123;           e.printStackTrace();       &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;                   connection.close();               &#125;           &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;               e.printStackTrace();           &#125;       &#125;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RecyclerView使用小结</title>
    <link href="/2016/01/20/RecyclerViewE%CC%82%C2%B9O%CC%81A%CC%83%C3%90%C2%A1%C2%BDa%CC%81/"/>
    <url>/2016/01/20/RecyclerViewE%CC%82%C2%B9O%CC%81A%CC%83%C3%90%C2%A1%C2%BDa%CC%81/</url>
    
    <content type="html"><![CDATA[<p>最近在项目中多次使用了RecyclerView，其实真的使用起来还没有ListView简单，比如点击、长按事件都需要自己写，Item的间隔什么的都要自己写，用ListView根本就不用管的好嘛。<br>但是呢，和它的优点比起来，这些缺点根本就不是事:</p><ul><li>高度可定制性，以轻松的通过这个控件实现ListView,GirdView，瀑布流等效果，同时还可以增加Item增删动画，使用ItemDecoration给item添加自定义的间隔等等</li><li>性能优，个人测试当数据量较大的时候，ListView有明显卡顿而RecyclerView没有</li></ul><p>以下是个人在项目中使用时遇到的一些心得：<br>1.Item之间的间隔<br>RecyclerView默认没有间隔，不像ListView有一条线。使用时自己添加:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DividerItemDecoration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ItemDecoration</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] ATTRS = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;            android.R.attr.listDivider    &#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> VERTICAL_LIST = LinearLayoutManager.VERTICAL;    <span class="hljs-keyword">private</span> Drawable mDivider;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mOrientation;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DividerItemDecoration</span><span class="hljs-params">(Context context, <span class="hljs-keyword">int</span> orientation)</span> </span>&#123;        <span class="hljs-keyword">final</span> TypedArray a = context.obtainStyledAttributes(ATTRS);        mDivider = a.getDrawable(<span class="hljs-number">0</span>);        a.recycle();        setOrientation(orientation);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrientation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> orientation)</span> </span>&#123;        <span class="hljs-keyword">if</span> (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;invalid orientation&quot;</span>);        &#125;        mOrientation = orientation;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas c, RecyclerView parent)</span> </span>&#123;        Log.v(<span class="hljs-string">&quot;recyclerview - itemdecoration&quot;</span>, <span class="hljs-string">&quot;onDraw()&quot;</span>);        <span class="hljs-keyword">if</span> (mOrientation == VERTICAL_LIST) &#123;            drawVertical(c, parent);        &#125; <span class="hljs-keyword">else</span> &#123;            drawHorizontal(c, parent);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawVertical</span><span class="hljs-params">(Canvas c, RecyclerView parent)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = parent.getPaddingLeft();        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = parent.getWidth() - parent.getPaddingRight();        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childCount = parent.getChildCount();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;            <span class="hljs-keyword">final</span> View child = parent.getChildAt(i);            android.support.v7.widget.RecyclerView v = <span class="hljs-keyword">new</span> android.support.v7.widget.RecyclerView(parent.getContext());            <span class="hljs-keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child                    .getLayoutParams();            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> top = child.getBottom() + params.bottomMargin;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bottom = top + mDivider.getIntrinsicHeight();            mDivider.setBounds(left, top, right, bottom);            mDivider.draw(c);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHorizontal</span><span class="hljs-params">(Canvas c, RecyclerView parent)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> top = parent.getPaddingTop();        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bottom = parent.getHeight() - parent.getPaddingBottom();        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childCount = parent.getChildCount();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;            <span class="hljs-keyword">final</span> View child = parent.getChildAt(i);            <span class="hljs-keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child                    .getLayoutParams();            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = child.getRight() + params.rightMargin;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = left + mDivider.getIntrinsicHeight();            mDivider.setBounds(left, top, right, bottom);            mDivider.draw(c);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getItemOffsets</span><span class="hljs-params">(Rect outRect, <span class="hljs-keyword">int</span> itemPosition, RecyclerView parent)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mOrientation == VERTICAL_LIST) &#123;            outRect.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mDivider.getIntrinsicHeight());        &#125; <span class="hljs-keyword">else</span> &#123;            outRect.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mDivider.getIntrinsicWidth(), <span class="hljs-number">0</span>);        &#125;    &#125;&#125;</code></pre><p>然后给RecyclerView设置ItemDecoration即可</p><pre><code class="hljs java">mRecyclerView.addItemDecoration(<span class="hljs-keyword">new</span> DividerItemDecoration(<span class="hljs-keyword">this</span>,DividerItemDecoration.VERTICAL_LIST));</code></pre><p>2.Item点击效果<br>RecyclerView默认没有点击效果，ListView点击Item背景会变暗，这样可以给用户很清晰的感知，RecyclerView点了看不出来效果，不知道有没有反应也不清楚点击了哪一个，所以需要添加以明确的反馈，在item的布局文件里面添加：</p><pre><code class="hljs xml">android:clickable=&quot;true&quot;android:focusable=&quot;true&quot;android:background=&quot;?android:attr/selectableItemBackground&quot;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>recyclerview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit使用之自定义Converter</title>
    <link href="/2016/01/13/RetrofitE%CC%82%C2%B9O%CC%81A%CC%83O%CC%88%C2%AE%C3%97O%CC%82%C2%B6%C2%A8O%CC%80a%CC%8AConverter/"/>
    <url>/2016/01/13/RetrofitE%CC%82%C2%B9O%CC%81A%CC%83O%CC%88%C2%AE%C3%97O%CC%82%C2%B6%C2%A8O%CC%80a%CC%8AConverter/</url>
    
    <content type="html"><![CDATA[<p>&#160; &#160; &#160;&#160;Retrofit官方给了以下几个常用的转换库</p><ul><li>Gson: com.squareup.retrofit2:converter-gson</li><li>Jackson: com.squareup.retrofit2:converter-jackson</li><li>Moshi: com.squareup.retrofit2:converter-moshi</li><li>Protobuf: com.squareup.retrofit2:converter-protobuf</li><li>Wire: com.squareup.retrofit2:converter-wire</li><li>Simple XML: com.squareup.retrofit2:converter-simplexml</li><li>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</li></ul><p>&#160; &#160; &#160;&#160;这对于一般的使用来说确实够用了，但是如果我们对安全性要求比较高，或者编码不太一样的话，这些库就没法使用了，于是我们就需要自定义ConverterFactory。Retrofit已经为我们提供了自定义ConverterFactory的接口，我们只需要实现它给的接口即可，首先新建一个类继承Converter.Factory,这里也用到了Gson是因为项目需要解密之后是json字符串。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecodeConverterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Converter</span>.<span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DecodeConverterFactory <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> create(<span class="hljs-keyword">new</span> Gson());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DecodeConverterFactory <span class="hljs-title">create</span><span class="hljs-params">(Gson gson)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecodeConverterFactory(gson);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Gson gson;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DecodeConverterFactory</span><span class="hljs-params">(Gson gson)</span> </span>&#123;        <span class="hljs-keyword">if</span> (gson == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;gson == null&quot;</span>);        <span class="hljs-keyword">this</span>.gson = gson;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecodeResponseBodyConverter&lt;&gt;(adapter);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] annotations,Retrofit retrofit) &#123;        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecodeRequestBodyConverter&lt;&gt;(gson, adapter);    &#125;&#125;</code></pre><p>&#160; &#160; &#160;&#160;然后我们需要自定义responseBodyConverter和requestBodyConverter，这里我们发送请求的时候不需要加密，接收请求的时候需要解密，具体代码如下</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecodeResponseBodyConverter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">ResponseBody</span>, <span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TypeAdapter&lt;T&gt; adapter;    DecodeResponseBodyConverter(TypeAdapter&lt;T&gt; adapter) &#123;        <span class="hljs-keyword">this</span>.adapter = adapter;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">convert</span><span class="hljs-params">(ResponseBody value)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//解密字符串</span>        <span class="hljs-keyword">return</span> adapter.fromJson(EncryptUtils.decode(value.string()));    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecodeRequestBodyConverter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">RequestBody</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MediaType MEDIA_TYPE = MediaType.parse(<span class="hljs-string">&quot;application/json; charset=UTF-8&quot;</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset UTF_8 = Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Gson gson;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TypeAdapter&lt;T&gt; adapter;    DecodeRequestBodyConverter(Gson gson,TypeAdapter&lt;T&gt; adapter)&#123;        <span class="hljs-keyword">this</span>.gson = gson;        <span class="hljs-keyword">this</span>.adapter = adapter;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBody <span class="hljs-title">convert</span><span class="hljs-params">(T value)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Buffer buffer = <span class="hljs-keyword">new</span> Buffer();        Writer writer = <span class="hljs-keyword">new</span> OutputStreamWriter(buffer.outputStream(),UTF_8);        JsonWriter jsonWriter = gson.newJsonWriter(writer);        adapter.write(jsonWriter,value);        jsonWriter.flush();        <span class="hljs-keyword">return</span> RequestBody.create(MEDIA_TYPE,buffer.readByteString());    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>开源库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>retrofit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手机QQ聊天记录破解</title>
    <link href="/2016/01/13/E%CC%82O%CC%88%C2%BBu%CC%81QQA%CC%81A%CC%88I%CC%80i%CC%80%C2%BCC%CC%A7A%CC%82%C2%BC%C3%86%C3%86%C2%BDa%CC%82/"/>
    <url>/2016/01/13/E%CC%82O%CC%88%C2%BBu%CC%81QQA%CC%81A%CC%88I%CC%80i%CC%80%C2%BCC%CC%A7A%CC%82%C2%BC%C3%86%C3%86%C2%BDa%CC%82/</url>
    
    <content type="html"><![CDATA[<p>&#160; &#160; &#160;&#160;其实早在半年以前就研究过手机QQ聊天记录的破解，只是当时研究了一半没什么进展就放下了，现在业务需要，同时又有一些资料，就再次研究了这个问题。要想拿到聊天记录的数据库，当然首先需要root，聊天记录的数据库就在/data/data/com.tencent.mobileqq/databases/{所登录的QQ号码}.db。<img src="http://ww3.sinaimg.cn/mw690/723b2af4gw1ezqvih5ubnj20u01hc49l.jpg" alt="数据库位置"><br>&#160; &#160; &#160;&#160;手机QQ不像微信那样直接加密数据库，而是对数据库里面的字段进行加密，我们如果直接打开QQ的数据库，看到的是这样的!<img src="http://ww2.sinaimg.cn/mw690/723b2af4gw1ezqvihry8ej20u01hctbb.jpg" alt="QQ数据库">因此需要对数据的内容进行解密，其中解密的KEY为手机的IMEI。解密的重要代码如下</p><pre><code class="hljs java"><span class="hljs-comment">//传入字符串，输出解密结果</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] imeiArr = IMEI.toCharArray();<span class="hljs-comment">//手机IMEI</span>    <span class="hljs-keyword">int</span> imeiLen = imeiArr.length;    <span class="hljs-keyword">char</span>[] enArr = s.toCharArray();    <span class="hljs-keyword">int</span> enLen = enArr.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enLen; i++) &#123;        enArr[i] = (<span class="hljs-keyword">char</span>) (enArr[i] ^ imeiArr[i % imeiLen]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(enArr);&#125;</code></pre><p>上图好友列表，解密之后的结果为：<img src="http://ww4.sinaimg.cn/mw690/723b2af4gw1ezqwl7o5c6j20u01hctbi.jpg" alt="解密结果"><br>聊天记录及群列表同理。</p>]]></content>
    
    
    <categories>
      
      <category>安全攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>先导篇</title>
    <link href="/2016/01/01/I%CC%88E%CC%80%C2%B5%C2%BC%C3%86%C2%AA/"/>
    <url>/2016/01/01/I%CC%88E%CC%80%C2%B5%C2%BC%C3%86%C2%AA/</url>
    
    <content type="html"><![CDATA[<p>&#160; &#160; &#160;&#160;Happy New  Year!感觉元旦用英语说才更有感觉，春节用新年快乐更合适。2015对我来说是是人生中非常重要的一年，这一年离开学校开始工作，也是我经过三年低迷重拾斗志的第一年。<br>&#160; &#160; &#160;&#160;2014年暑假我才决定去做一名程序员，在这之前，大学前三年我完全找不到人生的方向，真的是在混日子，做的有意义的事屈指可数。做了两年微软校园大使，虽说没什么成绩，也没有和其他校园大使交上朋友，但是可以感受到大公司的那种工作氛围和办事效率，对我影响颇大。交了几个不错的朋友，没有他们，我无法想象我大学的后两年会怎么过，也不知道我的大学会以什么方式结束。也曾经去教授实验室呆过一两个月，学IOS软件开发，最后不了了之，但是这件事让我对移动软件开发有了一个初步的印象。谈恋爱，这个话题本来想略过的，不过还是觉得躲不过去。为啥想略过呢，因为对于情商为负数的我来说，这完全是稀里糊涂的，连我自己都弄不明白发生了什么，完全没法说。简单的总结三句话，喜欢的水中之月，不喜欢的昙花一现，互相喜欢的曲折离奇。<br>&#160; &#160; &#160;&#160;2015年，取毕业证，拿驾照，去公司报道，三件事情我是用连续三天完成的。这三件事也基本概括了这一年的大体路线。一不小心就毕业了，我还没来得及学完我想学习的东西，我要是早一年找到人生的方向，我也不会觉得毕业这么仓促。没办法，事情已经来了，只能硬着头皮上。不管你愿不愿意，它都会发生。于是我就被毕业了。<br>&#160; &#160; &#160;&#160;考驾照并没有想象的那么难，感觉学起来还是蛮轻松的，特别是当有几个小伙伴一起学车的时候，感觉就跟玩似得。教练人都很好，特别是吴教练，很有耐心。<br>&#160; &#160; &#160;&#160;对于只有不到一年编程经验，只有半年Android开发经验的我来说，找工作还是一件有点难度的事情，不像有的人，大学学了好几年了，BAT随便进。曾经也怀疑是不是不应该非要找Android开发的工作，但是对编程和Android的喜爱，让我坚持了下来。我很喜欢现在的这份工作，做起来很有热情，这半年，我在不断的学习，提高自己的技能，对Android开发有了一个较为全面的认识，差不多应该有Android初级工程师的水平了。  同时也入门了Python这门强大了语言，学习一门强大的脚本语言对于程序开发效率的提示是不言而喻的。不得不说，不断地学习新东西真是一个享受的过程。<br>&#160; &#160; &#160;&#160;每天下班了可以和室友一起自己做晚餐吃。吃完晚餐没事可以去打打篮球。当然，周末要是能和喜欢的人一起出去玩就更完美了，只可惜这一段曲折离奇的感情，难以掌控，难以如愿。<br>&#160; &#160; &#160;&#160;整个2015年还是挺不错的，过得很充实，感觉自己每一天都在进步，每一天都很有意义。<br>&#160; &#160; &#160;&#160;2016年开始了，在这个新的起点上，当然要取的新的进步。工作上，继续磨练学习Android开发，达到中级工程师的水平。生活上，要提高生活质量，开始关注自己的身体，开始学习理财。感情这件事情并不是靠努力就能有结果的，希望自己能多一些感性，少一些理性吧。总之，人生之路多坎坷，不忘初心，坚强努力。<br>&#160; &#160; &#160;&#160;<strong>结束语</strong>：其实早在去年就想搭建一个个人博客了，这个域名也是那个时候申请的，只是后来搭了拆，拆了搭，反复了很多次。这次终于是下定决心了，以后要抽出一点时间认真来维护这个博客，以交流技术为主，也会有一些生活记录吧。要是能顺便提高一下自己的文字能力，那也是极好的。</p>]]></content>
    
    
    <categories>
      
      <category>生活记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年轮</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
